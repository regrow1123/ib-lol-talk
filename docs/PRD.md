# ib-lol talk — PRD

## 1. 제품 개요

LoL 1v1 라인전을 시뮬레이션하는 **LLM 기반 텍스트 전략 게임**.

**한줄 요약**: LLM과 채팅하면서 LoL 라인전을 배우는 게임.

### 타겟 유저
- LoL에 관심 있지만 진입장벽이 높다고 느끼는 사람
- 챔피언 스킬과 라인전 기본기를 텍스트로 먼저 익히고 싶은 사람
- 의도 싸움/심리전을 즐기는 LoL 경험자

### 핵심 경험
1. **자연어로 의도 입력** → 상대가 읽고 대응 → 읽기 싸움
2. **교전 서술에서 스킬 메커니즘을 자연스럽게 설명** → 플레이하면서 배움
3. **상대방이 대응 이유를 설명** → 실전 지식 축적

---

## 2. 아키텍처

### 2.1 하이브리드 구조

```
클라이언트(상태 보유) → 서버(LLM 호출 + 데미지 계산 + 가드레일) → 클라이언트
```

| 역할 | 담당 | 설명 |
|------|------|------|
| **LLM** | 판정 | 의도 해석, AI 행동 결정, 적중/회피, 쿨다운/자원 관리, 거리/blocked, 서술, suggestions |
| **서버 (데미지 엔진)** | 수치 계산 | actions 기반 데미지/쉴드 계산 (LoL 공식), 룬/주문 효과 |
| **서버 (가드레일)** | 범위 검증 | HP/자원/쿨다운 클램프, CS 감소 방지 |
| **클라이언트** | 상태 보유 + UI | 전체 상태 보유, 매 턴 서버에 전송, UI 렌더링, suggestions 필터링 |

### 2.2 핵심 원칙

**LLM = 무엇이 일어났는지, 서버 = 얼마나 아픈지**

- LLM: "Q1 맞았고 Q2로 따라감, 상대는 W1 쉴드로 방어"
- 서버: Q1 데미지 + Q2 데미지 - W1 쉴드량 = 실제 HP 변화
- LLM은 수치를 모름 → 서술에 구체적 숫자 불필요

### 2.3 비고정 시간 모델 (스냅샷 방식)

턴 간 시간 간격은 **고정이 아님**.

- 전투 중이면 짧고 (1~2초), 파밍 중이면 길 수 있음 (5~10초)
- 하나의 턴에 여러 액션 포함 가능 (콤보, 양쪽 교환 등)
- 서버는 **스냅샷 저장소** — "이 턴이 끝난 후의 상태"만 기록
- LLM이 **다음 상태를 결정** — 쿨다운, 자원, 거리 등 시간 경과가 반영된 값을 직접 반환
- 서버는 LLM이 반환한 쿨다운/자원 값을 그대로 저장 (자체 차감/계산 없음)
- 데미지 엔진은 **즉시 효과만 계산** (스킬 데미지, 쉴드량 — 시간 경과와 무관한 것)

**왜 이 방식인가**: 플레이어의 한 선택이 "Q1으로 견제"일 수도, "미니언 정리하면서 CS 3개 먹기"일 수도 있다. 전자는 1초, 후자는 10초. 고정 시간으로 환산하면 부자연스러워진다.

### 2.4 역할 경계 (무엇을 누가 하는가)

| | LLM | 서버 |
|---|---|---|
| 스킬 적중/회피 | ✅ 판정 | ❌ |
| 데미지 수치 | ❌ | ✅ LoL 공식 계산 |
| 쿨다운 | ✅ 값 반환 | 클램프(≥0)만 |
| 자원 (에너지 등) | ✅ 값 반환 | 클램프(0~max)만 |
| 거리 / blocked | ✅ 값 반환 | 클램프(≥0)만 |
| CS 획득 | ✅ 판정 | 누적 + 레벨업 판정 |
| 레벨업 스탯 | ❌ | ✅ LoL 공식 |
| 적 스킬업 | ✅ 선택 | 유효성 검증 |
| HP 변화 | ❌ | ✅ 데미지 엔진 결과 |
| 서술 / 코멘트 | ✅ | ❌ |
| suggestions | ✅ 생성 | ❌ (클라이언트가 필터) |

### 2.5 Stateless 서버
- Vercel Serverless Functions
- 상태 저장 안 함 — 매 턴 클라이언트가 전체 상태 전송

### 2.6 비용 최적화
- **Prompt caching**: static(챔피언 데이터+규칙) / dynamic(현재 상태) 분리 → `cache_control`
- **LLM은 수치 계산 안 함**: actions + 상태값만 출력 → 출력 토큰 절약
- **History 압축**: 최근 2턴 원문, 이전은 1줄 요약

---

## 3. 게임 설계

### 3.1 HP 시스템
- **실제 수치 기반** (리신 Lv1: 645 HP, 레벨당 +108)
- UI에 실제 수치 표시 (예: 487 / 645)
- 데미지는 서버 데미지 엔진이 LoL 공식으로 계산
- LLM은 적중/회피만 판정, 수치 계산 안 함

### 3.2 거리 & 장애물

#### distance (숫자, 유닛)
두 챔프 간 거리. LLM이 매 턴 반환.
- 초기값: 800
- LLM이 행동 결과에 따라 변경 (돌진, 후퇴, 접근 등)

#### blocked (boolean)
두 챔프를 잇는 **직선 경로**에 미니언이 있는지.
- `true` → 투사체(Q1 등) 미니언에 막힘
- `false` → 투사체 직통
- E1(자기 주변 범위), R/AA(대상지정)는 blocked 무관
- 다른 위치에 미니언이 있어도, 직선 경로에 없으면 `false`

#### 스킬 사거리
각 스킬 사거리는 `data/champions/{id}.json`에 정의. 프롬프트에 동적 삽입.
- distance 300 + Q1(사거리 1200) → 사거리 내
- distance 300 + AA(사거리 125) → 사거리 밖
- LLM이 distance와 사거리를 비교해서 적중/회피 판정

### 3.3 턴 시스템
- **1턴 = 플레이어의 1개 의도** (자연어 입력)
- 콤보 전체가 1턴에 처리
- 상대방도 같은 턴에 대응 행동 실행
- **확률 요소 없음** — 의도 조합이 결과를 100% 결정

#### 턴 규모 자동 조절
| 상황 | 처리 |
|------|------|
| 양쪽 저강도 (파밍/대기) | 요약 처리 (시간 많이 흐름) |
| 한쪽이라도 고강도 (교전) | 세밀하게 처리 (시간 짧음) |

#### 끼어들기 (Interrupt)
- 플레이어 저강도 + AI 고강도 → 턴 중단 + 대응 기회
- "CS를 먹으려는 순간, 상대가 Q1을 날렸다!" 식 연출

### 3.4 자원 시스템
- 챔피언마다 다른 자원 타입 (에너지, 마나, 무자원 등)
- `data/champions/{id}.json`에 자원 관련 수치 정의
- **LLM이 자원 값을 직접 관리** — 사용/회복 반영한 턴 종료 시점 값 반환
- 서버는 0~maxResource 클램프만

### 3.5 쿨다운 시스템
- 스킬 쿨다운은 **초 단위**
- **LLM이 쿨다운 값을 직접 관리** — 스킬 사용 + 시간 경과 반영한 턴 종료 시점 값 반환
- 서버는 ≥0 클램프만
- 0 = 사용 가능, 양수 = 남은 쿨다운(초)

### 3.6 레벨업
- **서버가 100% 관리** (LLM 판정 아님)
- CS 기반 레벨 테이블:

| CS | 레벨 | 필요 CS |
|----|------|---------|
| 0 | 1 | - |
| 4 | 2 | 4 |
| 10 | 3 | 6 |
| 18 | 4 | 8 |
| 27 | 5 | 9 |
| 37 | 6 | 10 |
| 48 | 7 | 11 |

- 레벨업 시 `phase: 'skillup'` → 입력 비활성화 → 스킬 선택 → 완료 후 play
- **적 레벨업**: LLM이 `enemySkillUp` 필드로 스킬 선택 (상황 기반), 서버는 유효성 검증만

### 3.7 미니언 시스템
- 일정 턴 간격으로 새 웨이브 도착 (근접 3 + 원거리 3)
- 미니언끼리 자동 교전 → 자연 소멸
- 막타를 쳐야 CS로 인정
- 미니언 유무가 `blocked`에 영향
- LLM이 미니언 수 관리, 서버가 상태에 반영

### 3.8 승리 조건
- **킬**: 상대 HP 0
- **CS 50**: 먼저 CS 50 도달
- 동시 사망 없음 — 먼저 맞힌 쪽이 킬

---

## 4. 스킬 시스템

### 4.1 표기 규칙
- 스킬 구조는 **챔피언마다 다름** — recast 유무, 단계 수 등 JSON에 정의
- recast 스킬: 1단계 사용 후 2단계 재사용 가능 (예: 리신 Q1→Q2, W1→W2, E1→E2)
- 비recast 스킬: 단일 사용 (예: 리신 R)
- recast 스킬 표기: **Q1/Q2** (항상 숫자 포함, 맨 Q 단독 사용 금지)
- recast 스킬의 쿨다운은 스킬 전체에 하나 (최종 단계 사용 후 쿨다운 시작)
- 기력 소모도 단계별로 다를 수 있음 (예: Q1: 50, Q2: 25)
- 모든 스킬 구조는 `data/champions/{id}.json`에 정의

### 4.2 챔피언 데이터
- `data/champions/{id}.json`에 독립 파일로 관리
- 스킬 사거리, 데미지 공식(baseDamage 배열, scaling ratio), recast 여부, 특수 메카닉 포함
- 프롬프트 생성 시 JSON에서 읽어 동적 삽입
- 챔피언 추가 = JSON 파일 추가 + 셋업 화면 추가. 코드 변경 불필요.

---

## 5. 상대방(AI)

### 5.1 행동 원칙
- **동등한 상대** — 봐주지 않음, 적극적으로 반격
- 플레이어 공격이 항상 성공하는 것 아님
- AI도 선공 가능, 편파 판정 금지
- **고정된 성격 없음** — 현재 상태(HP, 쿨다운, 거리, CS 차이)에 따라 유동적 판단
- **다양한 상황 연출** — 같은 패턴 반복 X, 여러 스킬 조합/전략 활용

### 5.2 말투
- 반말 종결: ~했음, ~됐음, ~인듯, ~ㅋㅋ
- 친근하게 + 대응 이유 + 팁
- 예: "잘 피했음", "Q2는 잃은 체력 비례라 지금 들어가면 더 아팠을듯"

### 5.3 교육적 역할
- 스킬 고유 효과를 상황에 맞게 활용 → 체험으로 학습
- 다양한 스킬 조합 (같은 패턴 반복 X)
- 대응 이유 설명으로 실전 지식 전달

---

## 6. Suggestions

### 6.1 LLM 생성
- 턴 응답에 **5~7개** suggestions 포함
- **스킬 태그**: `[{skill: "Q", text: "..."}, {skill: null, text: "..."}]`
- 미습득 스킬 포함 OK (클라이언트가 필터)
- 이모지 사용 금지

### 6.2 클라이언트 필터링
- 습득 여부 + 쿨다운(>0이면 비활성) 기준 필터링
- 필터 후 **최대 3개** 표시

### 6.3 스킬업 후 재필터링
- 레벨업 → 스킬 선택 → 저장된 suggestions 재필터링 → 새 스킬 관련 suggestion 노출
- 추가 API 호출 없음

### 6.4 게임 시작 시
- 챔피언 데이터 기반 스킬태그 suggestions
- 스킬 안 배운 상태 → 일반 suggestions만 표시
- 스킬업 후 해당 스킬 suggestions 노출

---

## 7. 소환사 주문 & 룬

### 소환사 주문 (5개 중 2개 자유 선택)
| 주문 | 효과 |
|------|------|
| 점멸 (Flash) | 즉시 이동, 회피/기습 |
| 점화 (Ignite) | 지속 피해 + 치유 감소 |
| 탈진 (Exhaust) | 둔화 + 피해 35% 감소 |
| 방어막 (Barrier) | 즉시 보호막 |
| 텔레포트 (TP) | 귀환 후 빠른 복귀 |

### 룬 (3개 중 1개 선택)
| 룬 | 특성 |
|------|------|
| 정복자 | 장기 교전. 스택 → AD 증가 + 회복 |
| 감전 | 짧은 교전. 3히트 시 추가 폭딜 |
| 착취의 손아귀 | 지속 체력전. AA → 추가 피해 + 회복 + 영구 체력 |

---

## 8. LLM 응답 형식

```json
{
  "narrative": "교전 서술 1~2문장",
  "aiChat": "상대방 코멘트. ~했음/~됐음 체",
  "actions": [
    {"who": "player", "skill": "Q1", "target": "enemy", "hit": true},
    {"who": "enemy", "skill": "E1", "target": "player", "hit": true}
  ],
  "distance": 100,
  "blocked": false,
  "cs": {"player": 2, "enemy": 1},
  "playerCooldowns": {"Q": 0, "W": 12, "E": 0, "R": 0},
  "enemyCooldowns": {"Q": 8, "W": 0, "E": 0, "R": 0},
  "playerResource": 125,
  "enemyResource": 175,
  "enemySkillUp": null,
  "suggestions": [
    {"skill": "Q", "text": "Q1으로 견제"},
    {"skill": null, "text": "안전하게 CS 챙기기"}
  ],
  "gameOver": null
}
```

### 서술 규칙
- **1~2문장** 이내. 간결하게.
- 스킬 효과 설명은 상황에 맞게 자연스럽게 포함

---

## 9. 게임 상태 스키마

```json
{
  "turn": 1,
  "phase": "play",
  "distance": 800,
  "blocked": true,
  "player": {
    "champion": "lee-sin",
    "hp": 645,
    "maxHp": 645,
    "resource": 200,
    "maxResource": 200,
    "resourceType": "energy",
    "level": 1,
    "cs": 0,
    "gold": 0,
    "ad": 69,
    "baseAd": 65,
    "armor": 36,
    "mr": 32,
    "skillLevels": {"Q": 0, "W": 0, "E": 0, "R": 0},
    "skillPoints": 1,
    "cooldowns": {"Q": 0, "W": 0, "E": 0, "R": 0},
    "shield": 0,
    "spells": ["flash", "ignite"],
    "spellCooldowns": [0, 0],
    "rune": "conqueror",
    "buffs": [],
    "debuffs": []
  },
  "enemy": { "...same structure..." },
  "minions": {
    "player": {"melee": 3, "ranged": 3},
    "enemy": {"melee": 3, "ranged": 3}
  },
  "winner": null
}
```

---

## 10. 프로그램 흐름

### 게임 시작
```
[셋업 화면] 주문/룬 선택
  → POST /api/start (spells, rune)
  → 서버: 초기 상태 생성
  → 클라이언트: state 저장, phase='skillup'
  → 스킬 선택 UI (suggestions 영역)
  → POST /api/skillup
  → 서버: 검증 + 상태 업데이트
  → suggestions 필터링 → 입력 활성화
```

### 일반 턴
```
[플레이어 입력] "Q1으로 견제"
  → POST /api/turn (gameState, input, history)
  → 서버:
    1. LLM 호출 → actions, cooldowns, resource, distance, blocked, cs, ...
    2. 데미지 엔진: actions 기반 데미지/쉴드 계산
    3. LLM 반환 쿨다운/자원 적용
    4. CS 누적 → 레벨업 판정
    5. 가드레일 (HP/자원/쿨다운 클램프)
    6. gameOver 체크 (HP 0 / CS 50)
  → 클라이언트:
    1. narrative → 시스템 메시지
    2. aiChat → 상대방 말풍선
    3. state 업데이트 → 상태바 렌더링
    4. suggestions 필터링 → 칩 버튼 (최대 3개)
    5. levelUp → 스킬 선택 UI (입력 비활성화)
    6. gameOver → 게임오버 오버레이
```

### 레벨업 (턴 중간)
```
[턴 결과에 levelUp 포함]
  → 입력 비활성화, suggestions에 스킬 선택 버튼
  → POST /api/skillup → 검증 + 상태 업데이트
  → skillPoints 0이면 → 저장된 suggestions 재필터링 → 입력 활성화
  → skillPoints 남으면 → 다시 스킬 선택 UI
```

### 게임 오버
```
[gameOver 수신]
  → 오버레이 (승패 + 요약)
  → 복기하기 / 새 게임
```

---

## 11. UI/UX

### 셋업 화면
- 소환사 주문 2개 선택 (DDragon 아이콘)
- 룬 1개 선택 (DDragon 아이콘)
- 시작 버튼

### 게임 화면 — KakaoTalk 스타일 채팅
- **노란 말풍선** = 내 입력 (오른쪽)
- **흰 말풍선** = 상대방 (왼쪽, 챔피언 프로필 이미지)
- **시스템 메시지** = 서술 (중앙, 날짜 구분선 스타일)
- 상단: 양측 상태 (HP 실제 수치, 자원, CS, 레벨, 쿨다운 아이콘, 룬)
- 하단: 텍스트 입력 + suggestions 칩 버튼
- 스킬업 시: suggestions 영역에 Q/W/E 선택 버튼 + 전송 비활성화
- 게임오버: 오버레이 (승패 + 요약 + 복기/재시작)
- **턴 번호 표시 안 함**

### 아이콘
- DDragon CDN: `https://ddragon.leagueoflegends.com/cdn/14.20.1`
- 스킬/주문/룬/챔피언 초상화 모두 실제 게임 이미지

---

## 12. 기술 스택

| 구분 | 기술 |
|------|------|
| 프론트엔드 | 바닐라 HTML/CSS/JS |
| 서버 | Vercel Serverless Functions (Node.js ESM) |
| LLM | Anthropic Claude (`claude-sonnet-4-6`, `LLM_MODEL` env) |
| 배포 | Vercel |
| 소스 | GitHub (`regrow1123/ib-lol-talk`) |

---

## 13. 파일 구조

```
ib-lol-talk/
├── src/
│   ├── index.html
│   ├── css/style.css
│   └── js/main.js
├── api/
│   ├── start.js          # 게임 시작 (LLM 호출 없음)
│   ├── turn.js           # 턴 처리 (LLM 호출 + 데미지 엔진)
│   └── skillup.js        # 스킬 레벨업 (검증만, LLM 호출 없음)
├── server/
│   ├── llm.js            # LLM API 호출 + JSON 파싱 + 재시도
│   ├── prompt.js          # 프롬프트 생성 (static/dynamic 분리)
│   ├── damage.js          # 데미지 엔진 (LoL 공식, 즉시 효과만)
│   ├── validate.js        # 가드레일 검증 (클램프)
│   ├── game.js            # 상태 생성 + 초기화 + 레벨 테이블
│   └── champions.js       # 챔피언 JSON 로더
├── data/
│   └── champions/
│       └── lee-sin.json
├── docs/
│   └── PRD.md
├── vercel.json
└── package.json
```

---

## 14. API 엔드포인트

### POST /api/start
- Input: `{spells: [2개], rune: string}`
- Output: `{state, narrative, suggestions}`
- LLM 호출 없음

### POST /api/turn
- Input: `{gameState, input, history}`
- Output: `{state, narrative, aiChat, suggestions, levelUp, gameOver}`
- 흐름: LLM → actions + 상태값 → 데미지 엔진 → 가드레일 → 응답

### POST /api/skillup
- Input: `{gameState, skill}`
- Output: `{ok, state}`
- LLM 호출 없음

---

## 15. 로드맵

### Phase 1: 클린 재구현 (현재)
- [ ] 전체 코드 재작성
- [ ] 프롬프트 재작성
- [ ] E2E 테스트
- [ ] LLM 응답 품질 튜닝

### Phase 2: 폴리시
- [ ] AI 행동 다양성 개선
- [ ] 밸런스 튜닝
- [ ] UI/UX 개선, 모바일 최적화

### Phase 3: 챔피언 확장
- [ ] 셋업 화면 챔피언 선택 UI
- [ ] 2~3개 챔피언 추가
- [ ] 비대칭 매치업
